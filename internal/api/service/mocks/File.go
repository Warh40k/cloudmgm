// Code generated by mockery v2.42.0. DO NOT EDIT.

package mocks

import (
	domain "github.com/Warh40k/cloud-manager/internal/domain"
	afero "github.com/spf13/afero"
	mock "github.com/stretchr/testify/mock"

	multipart "mime/multipart"

	uuid "github.com/google/uuid"
)

// File is an autogenerated mock type for the File type
type File struct {
	mock.Mock
}

// ComposeZipArchive provides a mock function with given fields: files, fs
func (_m *File) ComposeZipArchive(files []domain.File, fs afero.Fs) (string, error) {
	ret := _m.Called(files, fs)

	if len(ret) == 0 {
		panic("no return value specified for ComposeZipArchive")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func([]domain.File, afero.Fs) (string, error)); ok {
		return rf(files, fs)
	}
	if rf, ok := ret.Get(0).(func([]domain.File, afero.Fs) string); ok {
		r0 = rf(files, fs)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func([]domain.File, afero.Fs) error); ok {
		r1 = rf(files, fs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFile provides a mock function with given fields: file
func (_m *File) CreateFile(file domain.File) (uuid.UUID, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for CreateFile")
	}

	var r0 uuid.UUID
	var r1 error
	if rf, ok := ret.Get(0).(func(domain.File) (uuid.UUID, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(domain.File) uuid.UUID); ok {
		r0 = rf(file)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uuid.UUID)
		}
	}

	if rf, ok := ret.Get(1).(func(domain.File) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFile provides a mock function with given fields: fileId
func (_m *File) DeleteFile(fileId uuid.UUID) error {
	ret := _m.Called(fileId)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uuid.UUID) error); ok {
		r0 = rf(fileId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetFileInfo provides a mock function with given fields: id
func (_m *File) GetFileInfo(id uuid.UUID) (domain.File, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetFileInfo")
	}

	var r0 domain.File
	var r1 error
	if rf, ok := ret.Get(0).(func(uuid.UUID) (domain.File, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(uuid.UUID) domain.File); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(domain.File)
	}

	if rf, ok := ret.Get(1).(func(uuid.UUID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVolumeFiles provides a mock function with given fields: volumeId
func (_m *File) ListVolumeFiles(volumeId uuid.UUID) ([]domain.File, error) {
	ret := _m.Called(volumeId)

	if len(ret) == 0 {
		panic("no return value specified for ListVolumeFiles")
	}

	var r0 []domain.File
	var r1 error
	if rf, ok := ret.Get(0).(func(uuid.UUID) ([]domain.File, error)); ok {
		return rf(volumeId)
	}
	if rf, ok := ret.Get(0).(func(uuid.UUID) []domain.File); ok {
		r0 = rf(volumeId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.File)
		}
	}

	if rf, ok := ret.Get(1).(func(uuid.UUID) error); ok {
		r1 = rf(volumeId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchFile provides a mock function with given fields: filename
func (_m *File) SearchFile(filename string) ([]domain.File, error) {
	ret := _m.Called(filename)

	if len(ret) == 0 {
		panic("no return value specified for SearchFile")
	}

	var r0 []domain.File
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]domain.File, error)); ok {
		return rf(filename)
	}
	if rf, ok := ret.Get(0).(func(string) []domain.File); ok {
		r0 = rf(filename)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.File)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(filename)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadFile provides a mock function with given fields: volumePath, file, fileName, fs
func (_m *File) UploadFile(volumePath string, file multipart.File, fileName string, fs afero.Fs) (string, error) {
	ret := _m.Called(volumePath, file, fileName, fs)

	if len(ret) == 0 {
		panic("no return value specified for UploadFile")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, multipart.File, string, afero.Fs) (string, error)); ok {
		return rf(volumePath, file, fileName, fs)
	}
	if rf, ok := ret.Get(0).(func(string, multipart.File, string, afero.Fs) string); ok {
		r0 = rf(volumePath, file, fileName, fs)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, multipart.File, string, afero.Fs) error); ok {
		r1 = rf(volumePath, file, fileName, fs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewFile creates a new instance of File. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFile(t interface {
	mock.TestingT
	Cleanup(func())
}) *File {
	mock := &File{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
